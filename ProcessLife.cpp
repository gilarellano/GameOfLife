// Class to implement to rules of Conway's Game of Life

#include <iostream>
#include <string>
#include "ProcessLife.h"

ProcessLife::ProcessLife(std::string boundaryRule, int rows, int columns, float populationDensity) {

    SetBoundaryRule(boundaryRule);

    // Create random generated board w/ population density
    CreateLife lifeGenerator(rows,columns,populationDensity);
    this->rows = lifeGenerator.GetNumOfRows();
    this->columns = lifeGenerator.GetNumOfColumns();

    this->rowsForMarginBoard = this->rows + 2;
    this->columnsForMarginBoard = this->columns + 2;
    
    this->currentBoard = new char*[this->rowsForMarginBoard];   
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        this->currentBoard[i] = new char[this->columnsForMarginBoard];
    }

    this->prevBoard = new char*[this->rowsForMarginBoard];   
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        this->prevBoard[i] = new char[this->columnsForMarginBoard];
    }

    // Applies the boundary rules to the initial currentBoard
    this->tempBoard = lifeGenerator.GetArray();
    CopyArray(this->currentBoard, this->tempBoard); // Creates a deep copy of the board generated by lifeGenerator
    ApplyBoundaryRules(this->currentBoard);

    // Create an empty array for the initial prevBoard
    lifeGenerator.CreateArray(0);
    this->tempBoard = lifeGenerator.GetArray();
    CopyArray(this->prevBoard, this->tempBoard);
    ApplyBoundaryRules(this->prevBoard);

}

ProcessLife::ProcessLife(std::string boundaryRule, std::string inputTextFile) {

    SetBoundaryRule(boundaryRule);

    // Create board from either .txt or randomly generated
    CreateLife lifeGenerator(inputTextFile);
    this->rows = lifeGenerator.GetNumOfRows();
    this->columns = lifeGenerator.GetNumOfColumns();

    this->rowsForMarginBoard = this->rows + 2;
    this->columnsForMarginBoard = this->columns + 2;
    
    this->currentBoard = new char*[this->rowsForMarginBoard];   
    for (int i = 0; i < this->columnsForMarginBoard; i++) {
        this->currentBoard[i] = new char[this->columnsForMarginBoard];
    }

    this->prevBoard = new char*[this->rowsForMarginBoard];   
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        this->prevBoard[i] = new char[this->columnsForMarginBoard];
    }

    this->tempBoard = new char*[this->rowsForMarginBoard];   
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        this->tempBoard[i] = new char[this->columnsForMarginBoard];
    }

    // Applies the boundary rules to the initial currentBoard
    this->tempBoard = lifeGenerator.GetArray();
    CopyArray(this->currentBoard, this->tempBoard); // Creates a deep copy of the board generated by lifeGenerator
    ApplyBoundaryRules(this->currentBoard);

    // Create an empty array for the initial prevBoard
    lifeGenerator.CreateArray(0);
    this->tempBoard = lifeGenerator.GetArray();
    CopyArray(this->prevBoard, this->tempBoard);
    ApplyBoundaryRules(this->prevBoard);
}

// Create a deep-value copy of the array generated by CreateLife
void ProcessLife::CopyArray(char** boardToCopy, char** board) {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
            boardToCopy[i][j] = board[i][j];
        }
    }

}

ProcessLife::~ProcessLife() {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        delete [] this->currentBoard[i];
        delete [] this->prevBoard[i];
    }
    delete [] this->currentBoard;
    delete [] this->prevBoard;

}

void ProcessLife::ProcessBoard() {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
            
            // No need to analyze the perimeter
            if ( (i == 0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) {
               continue; 

            } else {

                this->numOfNeighbors = CountNumOfNeighbors(this->currentBoard, i, j);

                // Implement Game of Life Rules
                if (this->numOfNeighbors <= 1) {            // If there is 1 or less neighbor, cell dies from underpopulation
                    this->prevBoard[i][j] = '-';
                } else if (this->numOfNeighbors == 2) {     // If there is 2 neighbors, cell is stable
                    if (this->currentBoard[i][j] == 'X') { 
                        this->prevBoard[i][j] = 'X';
                    } else {
                        this->prevBoard[i][j] = '-';
                    }
                } else if (this->numOfNeighbors == 3) {     // If there is 3 neighbors, a cell is born
                    this->prevBoard[i][j] = 'X';
                } else {                                    // If there is 4 or more, cell dies from overpopulation
                    this->prevBoard[i][j] = '-';
                }

            }
        }
    }

    ApplyBoundaryRules(this->prevBoard);

    this->tempBoard = this->currentBoard;    
    this->currentBoard = this->prevBoard;
    this->prevBoard = this->tempBoard;

}

/* Count the neighboring cells by iterating around i & j positon
 * (-i,-j) (-i,j) (-i,+j) 
 * (i, -j) (i, j) (i, +j)
 * (+i,-j) (+i,j) (+i,+j) */
int ProcessLife::CountNumOfNeighbors(char** &board, int i, int j) {

    int numOfNeighbors = 0; // Reset the count

    for (int x = -1; x <= 1; x++) {
       for (int y = -1; y <= 1; y++) {
            // Avoids counting itself as a live cell
            if (!(x == 0 && y == 0)) { 
                if (board[i+x][j+y] == 'X') {
                    numOfNeighbors++; 
                }
            }
        }
    }

    return numOfNeighbors;
}

void ProcessLife::ApplyBoundaryRules(char** &board) {

    if (this->boundaryRule == CLASSIC) { CreateClassicBoard(board); }
    else if (this->boundaryRule == MIRROR) { CreateMirrorBoard(board); }
    else if (this->boundaryRule == DOUGHNUT) { CreateDoughnutBoard(board); }

}

void ProcessLife::SetBoundaryRule(std::string boundaryRule) {

    if (boundaryRule == "classic") { this->boundaryRule = CLASSIC; }
    else if (boundaryRule == "mirror") { this->boundaryRule = MIRROR; }
    else if (boundaryRule == "doughnut") { this->boundaryRule = DOUGHNUT; }

}

// Classic Rule: The boundaries would all be dead cells
void ProcessLife::CreateClassicBoard(char** &board) {
    
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
                        
            if ( (i ==0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) { // Access to outer perimeter only
                board[i][j] = '-';

            // Leave the core values as is
            } else { 
                continue;
            }
        }
    }

};

/* Mirror Rule: The boundaries reflect eachother
*             A A B C C
*  A B C      A A B C C
*  H - D  ->  H H - D D  
*  G F E      G G F E E
*             G G F E E                      
*/
void ProcessLife::CreateMirrorBoard(char** &board) {
    
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
           
            // This allows us to manipulate the outer edges only 
            if ( (i == 0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) { 
                
                // Top Left Corner
                if (i == 0 && j == 0) {
                    board[i][j] = board[i+1][j+1];
                
                // Top Right Corner
                } else if ( i == 0 && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[i+1][(j - 2)+1];

                // Bottom Left Corner
                } else if ((i == this->rowsForMarginBoard - 1) && j == 0) {
                    board[i][j] = board[(i - 2)+1][j+1];
                
                // Bottom Right Corner
                } else if ((i == this->rowsForMarginBoard - 1) && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[(i - 2)+1][(j - 2)+1];
                
                // Top Row
                } else if (i == 0  && (j > 0 || j < this->columnsForMarginBoard - 2)) {
                    board[i][j] = board[i+1][(j - 1)+1];
                
                // Bottom Row
                } else if ((i == this->rowsForMarginBoard - 1) && (j > 0 || j < this->columnsForMarginBoard - 2)) {
                    board[i][j] = board[(i - 2)+1][(j - 1)+1];
                
                // Left Column
                } else if ((i > 0 || i < this->rowsForMarginBoard - 2) && j == 0) {
                    board[i][j] = board[(i - 1)+1][j+1];
                
                // Right Column
                } else if ((i > 0 || i < this->rowsForMarginBoard - 1) && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[(i - 1)+1][(j - 2)+1];
                }
                
            // Leave the core values as-is
            } else {
                continue;
            }
        }
    }
}

/* Doughnut Mode: The boundaries wrap around
* left column boundary wraps to right column, same w/ bottom & top rows
* Corners wrap around diagonally
* 
*             E G F E G
*  A B C      C A B C A
*  H - D  ->  D H - D H  
*  G F E      E G F E G
*             C A B C A                
*/
void ProcessLife::CreateDoughnutBoard(char** &board) {
    
    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {

            // This allows us to manipulate the outer edges only 
            if ( (i == 0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) {
                
                // Top Left Corner
                if (i == 0 && j == 0) {
                    board[i][j] = board[this->rows][this->columns];
                
                // Top Right Corner
                } else if ( i == 0 && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[this->rows][1];

                // Bottom Left Corner
                } else if ((i == this->rowsForMarginBoard - 1) && j == 0) {
                    board[i][j] = board[1][this->columns];
                
                // Bottom Right Corner
                } else if ((i == this->rowsForMarginBoard - 1) && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[1][1];
                
                // Top Row
                } else if (i == 0  && (j > 0 || j < this->columnsForMarginBoard - 2)) {
                    board[i][j] = board[this->rows][j];
                
                // Bottom Row
                } else if ((i == this->rowsForMarginBoard - 1) && (j > 0 || j < this->columnsForMarginBoard - 2)) {
                    board[i][j] = board[1][j];
                
                // Left Column
                } else if ((i > 0 || i < this->rowsForMarginBoard - 2) && j == 0) {
                    board[i][j] = board[i][this->columns];
        
                // Right Column
                } else if ((i > 0 || i < this->rowsForMarginBoard - 1) && (j == this->columnsForMarginBoard - 1)) {
                    board[i][j] = board[i][1];
                }

            // Leave the core values as is
            } else { 
                continue;
            }
        }
    }
}

// Checks if currBoard is empty
bool ProcessLife::IsEmpty() {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
            if (this->currentBoard[i][j] != '-') {
                return false;
            }
        }
    }
    return true;
}

// Checks if curr and prev board are the same, meaning it has stabilized
bool ProcessLife::IsEqual() {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {

            // Skip the outer boundaries
            if ( (i == 0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) {
                continue;
            
            // Only check core values
            } else { 
                if (this->currentBoard[i][j] != this->prevBoard[i][j]) {
                    return false;
                }
            }
        }
    }

    return true;

}

void ProcessLife::OutputBoard(std::ostream& stream, char** &board) {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
            stream << board[i][j] << " ";
        }
        stream << std::endl;
    }
    stream << std::endl;
}

// Outputs the current board
void ProcessLife::OutputCurrBoard(std::ostream& stream) {

    for (int i = 0; i < this->rowsForMarginBoard; i++) {
        for (int j = 0; j < this->columnsForMarginBoard; j++) {
            // Skips the boundaries
            if ( (i == 0 || i == (this->rowsForMarginBoard - 1)) || (j == 0 || j == (this->columnsForMarginBoard - 1)) ) {
                continue;
            } else {
                stream << this->currentBoard[i][j] << " ";
            }
        }
        stream << std::endl;
    }

}

// For debuggin this class
/*int main() {
    ProcessLife process("classic", 10, 10, 1);
    //ProcessLife process("mirror", "input.txt");

    return 0;
}*/